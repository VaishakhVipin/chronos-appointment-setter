1. Twilio Integration
A. SMS Notification Flow
Goal: After a booking is created, send an SMS to the user to confirm the booking.
Steps:
Install Twilio SDK:
pip install twilio
Configure Twilio credentials:
Add TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, and TWILIO_PHONE_NUMBER to your .env.
Create a utility function:
send_sms(to_number, message) that uses Twilio’s REST API to send SMS.
Trigger SMS after booking:
In your booking flow (after a successful booking), call send_sms to notify the user.
The SMS should include a confirmation and a prompt for the user to reply or check their email for the meeting link.
(Optional) Webhook for SMS replies:
Set up a Twilio webhook endpoint to receive and process SMS replies (e.g., for confirmations or rescheduling).
B. Voice Call Handling
Goal: Handle inbound and outbound calls, route audio to AssemblyAI for transcription, and pass transcript to Gemini for intent extraction and scheduling.
Steps:
Set up Twilio Voice webhook:
Create a FastAPI endpoint to handle Twilio’s call events (/twilio/voice).
Generate TwiML for call flow:
Respond to Twilio with TwiML to greet the user and start recording/streaming from the .wav files generated by deepgram.
Stream audio to AssemblyAI:
Use Twilio’s <Stream> (if available) or record and forward audio chunks to AssemblyAI’s real-time streaming endpoint.
Handle call hangup, errors, etc.:
Clean up resources and notify the user as needed.
2. AssemblyAI Integration
A. Real-Time Transcription
Goal: Transcribe user speech in real time with <300ms latency.
Steps:
Sign up and get AssemblyAI API key.
Install AssemblyAI SDK or use websockets:
Use their Universal Streaming API for low-latency transcription.
Stream audio from Twilio to AssemblyAI:
Forward audio chunks from the Twilio call to AssemblyAI’s websocket endpoint.
Receive partial/final transcripts:
As soon as a transcript is available, pass it to Gemini for intent extraction and scheduling logic.
Handle transcript events:
On each transcript, update the conversation state and possibly interrupt Twilio’s call flow if needed (e.g., if the user says “cancel”).
3. Integration with Gemini
On each transcript from AssemblyAI:
Pass the transcript to Gemini’s parse_intent and generate_llm_reply.
Use the AI’s response to drive the next step in the Twilio call (e.g., ask for more info, confirm booking, etc.).
If a booking is confirmed, trigger the SMS notification flow.
4. Implementation Plan: Step-by-Step
Phase 1: Twilio SMS
[ ] Add Twilio credentials to .env
[ ] Implement send_sms utility
[ ] Trigger SMS after booking
Phase 2: Twilio Voice + AssemblyAI Streaming
[ ] Set up Twilio Voice webhook endpoint
[ ] Respond with TwiML to start call and stream/record audio
[ ] Stream audio to AssemblyAI’s websocket API
[ ] Receive and process real-time transcripts
Phase 3: Real-Time AI Scheduling
[ ] On each transcript, call Gemini for intent extraction and reply
[ ] Use AI response to drive Twilio call flow (e.g., ask, confirm, end)
[ ] On booking confirmation, send SMS
Phase 4: Webhook for SMS Replies (Optional)
[ ] Set up endpoint to process incoming SMS for confirmations or rescheduling
5. Key Considerations
Latency: Use AssemblyAI’s streaming for <300ms transcript delivery.
State Management: Maintain session state for each call/SMS thread.
Security: Secure all webhooks and API keys.
Testing: Simulate calls and SMS flows with Twilio’s test tools.